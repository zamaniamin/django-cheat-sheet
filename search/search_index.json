{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About Python Monster","text":"<p>Hi</p> <p>Welcome to Python Monster \u2013 where the journey to mastering Python and becoming a senior backend developer unfolds! I'm a passionate Python programmer, sharing my learnings, experiences, and deep dives into the world of Python, Django, and Software Developing principles like SOLID and design patterns.</p> <p>The name \"Python Monster\" reflects my ambition to dominate backend development with Python, turning complex challenges into elegant, efficient code. This blog is a space where you'll find everything from tutorials and tips to insights on best practices, with a focus on writing clean, scalable, and maintainable software.</p> <p>Join me on the path to becoming a Python monster \u2013 a beast in backend development, equipped with the knowledge and skills to tackle any coding challenge.</p>"},{"location":"developing/","title":"Introduction To Software Developing","text":""},{"location":"developing/git/best-practices-for-git-commits/","title":"Best Practices For Git Commits","text":"<p>Committing code changes in a version control system like Git is a crucial part of the development process. Following best practices for Git commits can help make your project history more understandable and maintainable. Here are some best practices for Git commits:</p> <ol> <li> <p>Keep Commits Small and Focused:</p> <ul> <li>Each commit should represent a single, logical change. Avoid making multiple unrelated changes in a single commit.</li> <li>Smaller commits make it easier to understand the history and to identify when and why specific changes were made.</li> </ul> </li> <li> <p>Write Descriptive Commit Messages:</p> <ul> <li>Provide a clear and concise summary of the change in the commit message's first line. The summary should be under   72 characters.</li> <li>If necessary, provide a more detailed explanation of the change in the subsequent lines, leaving a blank line   after the summary.</li> <li>Use the imperative mood in the summary (e.g., \"Add feature\" instead of \"Added feature\").</li> <li>Include any relevant context, issue numbers, or references to external resources in the commit message.</li> </ul> </li> <li> <p>Follow a Consistent Style:</p> <ul> <li>Stick to a consistent naming convention and coding style for your commits. This makes it easier for team members   to understand and review your changes.</li> <li>Consider using prefixes in your commit messages to indicate the type of change (e.g., \"feat:\" for features, \"fix:\"   for bug fixes, \"docs:\" for documentation updates).</li> </ul> </li> <li> <p>Commit Often:</p> <ul> <li>Make small, incremental commits as you work on a feature or fix a bug. Frequent commits help in tracking progress   and identifying issues early.</li> <li>Avoid committing large, unmanageable changes all at once.</li> </ul> </li> <li> <p>Review Before Committing:</p> <ul> <li>Review your changes before committing to catch any typos, debugging statements, or unintentional changes.</li> <li>Run tests and ensure that your code builds successfully.</li> </ul> </li> <li> <p>Use Interactive Rebase:</p> <ul> <li>Before pushing your changes to a shared repository, consider using an interactive rebase to clean up your commit   history.</li> <li>Squash related commits together to create a more concise and meaningful history.</li> </ul> </li> <li> <p>Avoid Committing Generated or Temporary Files:</p> <ul> <li>Exclude generated files, build artifacts, and editor-specific files from version control by using <code>.gitignore</code>   files.</li> </ul> </li> <li> <p>Reference Issues and Pull Requests:</p> <ul> <li>If your project uses an issue tracker or pull request system (e.g., GitHub issues), reference the corresponding   issue or pull request in your commit message. This helps link code changes to specific tasks or discussions.</li> </ul> </li> <li> <p>Use Signed Commits When Appropriate:</p> <ul> <li>In some projects or organizations, signed commits may be required for security or compliance reasons. Learn how to   create signed commits if necessary.</li> </ul> </li> <li> <p>Commit Messages are for Humans:</p> <ul> <li>Remember that commit messages are primarily for humans to understand the history of the project. Write messages   that future you and your collaborators can easily understand.</li> </ul> </li> </ol> <p>Here's an example of a well-structured commit message:</p> <pre><code>feat: Add user authentication\n\n- Implement user registration and login functionality\n- Create user model and database schema\n- Update documentation with authentication details\n\nCloses #123\n</code></pre> <p>By following these best practices, you can maintain a clean and understandable Git commit history, which will make collaboration and code maintenance more efficient.</p>"},{"location":"developing/git/commit-message-structure/","title":"Commit Message Structure","text":""},{"location":"developing/git/commit-message-structure/#message-structure","title":"Message Structure","text":"<p>A well-structured Git commit message follows a consistent format that provides valuable information about the change being made. A typical Git commit message consists of three parts:</p> <ol> <li> <p>Type (Mandatory):</p> <ul> <li>The type specifies the purpose or nature of the commit. It describes what kind of change is being made. Common   commit types include:<ul> <li><code>feat</code>: A new feature or enhancement.</li> <li><code>fix</code>: A bug fix.</li> <li><code>docs</code>: Documentation updates.</li> <li><code>style</code>: Code style changes (e.g., formatting, indentation).</li> <li><code>refactor</code>: Code refactoring or restructuring that doesn't change behavior.</li> <li><code>test</code>: Adding or modifying tests.</li> <li><code>chore</code>: Maintenance or housekeeping tasks.</li> </ul> </li> </ul> </li> <li> <p>Scope (Optional):</p> <ul> <li>The scope provides additional context about where the change is applied within the project. It is often the name   of the module, file, or component affected by the change.</li> <li>The scope is enclosed in parentheses and separated from the type by a colon. For example:   <code>(auth): Add user authentication</code>.</li> </ul> </li> <li> <p>Description (Mandatory):</p> <ul> <li>The description is a concise and informative summary of the change. It should be clear and to the point.</li> <li>The description is written in the imperative mood (e.g., \"Add feature\" instead of \"Added feature\").</li> <li>It should be under 72 characters to ensure it is visible in most Git tools.</li> <li>You can use multiple lines for a more detailed explanation if needed, but leave a blank line after the first line.</li> </ul> </li> </ol>"},{"location":"developing/git/commit-message-structure/#feat","title":"feat","text":"<p>Here's an example of a well-structured Git commit message:</p> commit message<pre><code>feat(auth): Add user authentication\n\n- Implement user registration and login functionality.\n- Create user model and database schema.\n- Update documentation with authentication details.\n\nCloses #123\n</code></pre> <p>In this example:</p> <ul> <li><code>feat</code> indicates that it's a new feature.</li> <li><code>(auth)</code> provides context by specifying that the change is related to authentication.</li> <li>The description clearly states what the commit does.</li> <li>Bullet points are used for more detailed information.</li> <li><code>Closes #123</code> references an associated issue or task, indicating that this commit resolves it.</li> </ul>"},{"location":"developing/git/commit-message-structure/#fix","title":"fix","text":"<p>Here's an example of a Git commit message for a \"fix\":</p> commit message<pre><code>fix(validation): Correct form validation error\n\n- Fix a bug where the email validation regex was too restrictive.\n- Update regex pattern to allow for valid email addresses.\n- Ensure error messages are displayed correctly on the form.\n\nFixes #789\n</code></pre> <p>In this commit message:</p> <ul> <li><code>fix</code> specifies that it's a bug fix.</li> <li><code>(validation)</code> provides context about the area of the project where the fix is applied.</li> <li>The description clearly states what issue or bug is being fixed.</li> <li>Bullet points provide additional details on the changes made to address the bug.</li> <li><code>Fixes #789</code> references the issue number associated with the bug, indicating that this commit resolves it.</li> </ul>"},{"location":"developing/git/commit-message-structure/#style","title":"style","text":"<p>Here's an example of a Git commit message for a \"style\" change:</p> commit message<pre><code>style(formatting): Update code formatting\n\n- Standardize code formatting using the PEP 8 style guide.\n- Fix indentation inconsistencies and remove trailing whitespaces.\n- Ensure code is more readable and follows consistent styling rules.\n</code></pre> <p>In this commit message:</p> <ul> <li><code>style</code> specifies that it's a code style change.</li> <li><code>(formatting)</code> provides context about the type of style change being made.</li> <li>The description clearly states that the commit is focused on code formatting improvements.</li> <li>Bullet points provide specific details about the formatting changes made to improve code consistency and readability.</li> </ul> <p>\"Style\" commits are typically used for changes that don't affect the code's functionality but focus on improving code aesthetics and maintainability.</p>"},{"location":"developing/git/commit-message-structure/#docs","title":"docs","text":"<p>Here's an example of a Git commit message for a \"docs\" change:</p> commit message<pre><code>docs(readme): Update project README\n\n- Add installation instructions for Windows users.\n- Include a troubleshooting section to address common issues.\n- Improve clarity and grammar throughout the README.\n</code></pre> <p>In this commit message:</p> <ul> <li><code>docs</code> specifies that it's a documentation update.</li> <li><code>(readme)</code> provides context about the specific documentation being modified (in this case, the project README).</li> <li>The description clearly states that the commit is focused on updating the documentation.</li> <li>Bullet points provide specific details about the changes made to improve the README, such as adding instructions and   improving readability.</li> </ul> <p>\"Docs\" commits are used for documentation-related changes, such as updating README files, adding comments, or improving inline code documentation to make it more informative and understandable.</p>"},{"location":"developing/git/commit-message-structure/#refactor","title":"refactor","text":"<p>Here's an example of a Git commit message for a \"refactor\" change:</p> commit message<pre><code>refactor(api): Simplify user authentication logic\n\n- Reorganize the authentication code to improve readability.\n- Remove redundant functions and simplify the authentication process.\n- Enhance code maintainability by breaking down complex logic into smaller functions.\n</code></pre> <p>In this commit message:</p> <ul> <li><code>refactor</code> specifies that it's a code refactoring.</li> <li><code>(api)</code> provides context about the specific area of the codebase where the refactoring is taking place (in this case,   the API).</li> <li>The description clearly states that the commit is focused on code refactoring.</li> <li>Bullet points provide specific details about the changes made to simplify and improve the codebase.</li> </ul> <p>\"Refactor\" commits are used when you make changes to the code to enhance its structure, readability, and maintainability without changing its external behavior or adding new features.</p>"},{"location":"developing/git/commit-message-structure/#test","title":"test","text":"<p>Here's an example of a Git commit message for a \"test\" change:</p> commit message<pre><code>test(unit): Add unit tests for the UserAuthService\n\n- Create comprehensive unit tests to cover authentication scenarios.\n- Ensure that user registration, login, and password reset functions are thoroughly tested.\n- Achieve 100% test coverage for the UserAuthService module.\n</code></pre> <p>In this commit message:</p> <ul> <li><code>test</code> specifies that it's a change related to testing.</li> <li><code>(unit)</code> provides context about the type of tests being added or modified (in this case, unit tests).</li> <li>The description clearly states that the commit is focused on adding unit tests.</li> <li>Bullet points provide specific details about the tests added and their objectives.</li> </ul> <p>\"Test\" commits are used for changes related to testing, such as adding new tests, improving test coverage, or fixing existing tests to ensure the codebase remains reliable and well-tested.</p> <p>Following a consistent commit message structure makes it easier for team members to understand the purpose of each commit and navigate the project's history effectively. It also facilitates automated release notes generation and integration with issue tracking systems.</p>"},{"location":"developing/git/commit-message-structure/#chore","title":"chore","text":"<p>Here's an example of a Git commit message for a \"chore\" change:</p> commit message<pre><code>chore(build): Update build scripts and dependencies\n\n- Upgrade build tools to the latest versions for improved performance.\n- Update third-party dependencies to address security vulnerabilities.\n- Refactor build scripts to enhance build process efficiency.\n</code></pre> <p>another example:</p> commit message<pre><code>chore(ci): Update CI/CD configuration\n\n- Upgrade the CI/CD pipeline to use the latest version of the build and test tools.\n- Adjust environment variables to improve deployment automation.\n- Optimize build process for faster integration testing.\n</code></pre> <p>In this commit message:</p> <ul> <li><code>chore</code> specifies that it's a maintenance or housekeeping task.</li> <li><code>(build)</code> provides context about the specific area of the project related to the build process.</li> <li>The description clearly states that the commit is focused on updating build scripts and dependencies.</li> <li>Bullet points provide specific details about the changes made, such as upgrading tools, updating dependencies, and   refactoring scripts.</li> </ul> <p>\"Chore\" commits are used for general tasks that are not related to adding new features, fixing bugs, or improving documentation or tests. These can include tasks such as updating build configurations, refactoring code for performance, or any other maintenance activities that don't fall into the specific categories of other commit types.</p> <p>Tip: Removing a TODO comment from your code typically falls under the category of a \"chore\" commit.</p> <p>A \"chore\" commit is used for maintenance or housekeeping tasks. These tasks include actions that do not affect the code's functionality but are necessary for the project's upkeep, organization, or overall improvement. Removing TODO comments falls into this category because it involves cleaning up the codebase and ensuring that it doesn't contain unnecessary or outdated comments, improving the code's readability and maintainability.</p>"},{"location":"developing/git/generate-commit-message-with-ai-assistant/","title":"Generate Commit Message with AI Assistant","text":"<p>\u2728 Automate conventional Git commits in PyCharm! This AI prompt generates clean, structured messages (type, scope, summary, details) in seconds. Say goodbye to messy commits!</p> <p>Go to Pycharm and follow these steps:</p> <ol> <li>Press <code>Ctrl</code>+<code>Alt</code>+<code>S</code> to open settings and then select <code>Tools | AI Assistant | Prompt Library</code>.</li> <li>In the <code>Built-In Actions</code> section, select <code>Commit Message Generation</code>.</li> <li>In the editor field on the right, specify the rules for commit message generation, copy this prompt:</li> </ol> Prompt<pre><code>Generate a Git commit message that follows our conventional commit message structure. The commit message should contain\nthe following sections:\n\n1. **Type** (mandatory): Use one of the following types to specify the purpose of the commit:\n    - feat (new feature)\n    - fix (bug fix)\n    - docs (documentation changes)\n    - style (code formatting and style changes)\n    - refactor (code restructuring without behavior change)\n    - test (updates or additions to tests)\n    - chore (maintenance tasks)\n\n2. **Scope** (optional): If applicable, specify the project\u2019s module or component in parentheses immediately after the\n   type (e.g., feat(auth)).\n\n3. **Description** (mandatory): A one-line summary of the change in imperative mood and under 72 characters.\n\n4. **Body** (optional): If necessary, add one or more paragraphs with bullet points detailing the changes. Make sure\n   there\u2019s a blank line between the description and the body.\n\nHere is the expected structure:\n\n----------------------------------------------------------\n&lt;type&gt;(&lt;scope&gt;): &lt;Short description (max 72 chars)&gt;\n\n- &lt;Detailed change point 1&gt;\n- &lt;Detailed change point 2&gt;\n- &lt;More details if necessary&gt;\n\n----------------------------------------------------------\n\nFor example, if you are adding a user authentication feature, you might receive a prompt similar to:\n\nfeat(auth): Add user authentication\n\n- Implement user registration and login functionality.\n- Create user model and update the database schema.\n- Update documentation with authentication instructions.\n\nPlease generate the commit message based on the provided details.\n</code></pre> <p>Click Apply. Done. Say goodbye to messy commits!</p>"},{"location":"developing/solid_principles/solid_principles/","title":"SOLID Principles","text":""},{"location":"developing/solid_principles/srp/","title":"Single Responsibility Principle","text":""},{"location":"django/","title":"Django","text":""},{"location":"django/models/","title":"Models","text":""},{"location":"django/models/#relationships","title":"Relationships","text":"<ul> <li>Many-to-one relationships</li> <li>Many-to-many relationships</li> <li>One-to-one relationships</li> </ul> <p>source: DjangoProject</p>"},{"location":"django/testing/reduce-test-time/","title":"Reduce Test Time","text":"<p>Below is an overview of common factors that might be contributing to slower test runs and some approaches you can consider to reduce the overall execution time of your Django test suite.</p>"},{"location":"django/testing/reduce-test-time/#potential-reasons-for-slow-tests","title":"Potential Reasons for Slow Tests","text":"<ol> <li> <p>Database Setup:    By default, Django creates a test database and applies all migrations. If your project has a lot of migrations or if    the database operations are heavy, this step can take a noticeable amount of time.</p> </li> <li> <p>Password Hashing:    Django\u2019s default password hasher (PBKDF2) is intentionally slow for security reasons. Running tests that create users    and authenticate them can be slowed down if the default hasher is used.</p> </li> <li> <p>Test Fixtures and Factories:    If your tests rely on large fixtures or complex factories, the time to set up test data may add up.</p> </li> <li> <p>I/O and External Calls:    Tests that make real-world API calls, access external resources, or load many static or media files can add overhead.</p> </li> <li> <p>Lack of Parallelism:    Running tests sequentially means that even tests that could run concurrently are not taking advantage of multiple CPU    cores.</p> </li> </ol>"},{"location":"django/testing/reduce-test-time/#recommendations-to-reduce-test-time","title":"Recommendations to Reduce Test Time","text":"<p>1. Switch to a Faster Password Hasher in Tests: Replace the default hasher with a simpler one (e.g. <code>MD5PasswordHasher</code>) during testing. You can do this by adding a conditional setting. For example:</p> <pre><code># settings.py\n\nimport sys\n\nif 'test' in sys.argv:\n    PASSWORD_HASHERS = [\n        'django.contrib.auth.hashers.MD5PasswordHasher',\n    ]\n</code></pre> <p>This change will make password checks significantly faster during your tests without compromising real-world security.</p> <p>2. Use an In-Memory or Faster Test Database: Consider using SQLite\u2019s in-memory database for tests if your project allows it. You can set this up in a separate test settings file or conditionally in the main settings:</p> <pre><code># settings.py\n\nif 'test' in sys.argv:\n    DATABASES = {\n        'default': {\n            'ENGINE': 'django.db.backends.sqlite3',\n            'NAME': ':memory:',\n        }\n    }\n</code></pre> <p>An in-memory database can speed up database operations, especially for projects with a smaller dataset.</p> <p>3. Disable Migrations During Testing: Eliminating migration overhead can also speed up your tests. One popular method is to use a custom test runner or a small snippet in your settings to bypass migrations:</p> <pre><code># settings.py\n\nif 'test' in sys.argv:\n    class DisableMigrations:\n        def __contains__(self, item):\n            return True\n\n        def __getitem__(self, item):\n            return None\n\n\n    MIGRATION_MODULES = DisableMigrations()\n</code></pre> <p>This approach bypasses the migrations by telling Django that there are no migration files to apply.</p> <p>4. Optimize Test Data Setup: - Use Factories Over Fixtures: Factories (like those provided by Factory Boy) can create test data on demand and often avoid loading unnecessary data that fixtures might include. - Reduce Data Volume: Review whether all setup data are necessary for each test. Sometimes tests can be written to only set up what is strictly required.</p> <p>5. Parallel Test Execution: Django supports running tests in parallel by using the <code>--parallel</code> flag. For example:</p> <pre><code>py manage.py test --parallel\n</code></pre> <p>This tells Django to run tests concurrently, which can drastically cut down total test execution time on multi-core machines.</p> <p>6. Profile Your Tests: If the above tips do not give the desired improvement, consider using profiling tools to see where the time is spent. Django\u2019s test output or third-party packages can help pinpoint the slow parts of your test suite.</p>"},{"location":"django/testing/reduce-test-time/#final-thoughts","title":"Final Thoughts","text":"<p>Improving test speed is often a matter of balancing between testing fidelity and performance overhead. By switching to a faster password hasher, using an in-memory database, disabling migrations, optimizing your test data setup, and taking advantage of parallel test execution, you should see noticeable improvements.</p>"},{"location":"python/","title":"Introduction to Python","text":"<p>Python is an interpreted, object-oriented, high-level programming language with dynamic semantics. Its high-level built in data structures, combined with dynamic typing and dynamic binding, make it very attractive for Rapid Application Development, as well as for use as a scripting or glue language to connect existing components together. Python's simple, easy to learn syntax emphasizes readability and therefore reduces the cost of program maintenance. Python supports modules and packages, which encourages program modularity and code reuse. The Python interpreter and the extensive standard library are available in source or binary form without charge for all major platforms, and can be freely distributed.</p> <p>Often, programmers fall in love with Python because of the increased productivity it provides. Since there is no compilation step, the edit-test-debug cycle is incredibly fast. Debugging Python programs is easy: a bug or bad input will never cause a segmentation fault. Instead, when the interpreter discovers an error, it raises an exception. When the program doesn't catch the exception, the interpreter prints a stack trace. A source level debugger allows inspection of local and global variables, evaluation of arbitrary expressions, setting breakpoints, stepping through the code a line at a time, and so on. The debugger is written in Python itself, testifying to Python's introspective power. On the other hand, often the quickest way to debug a program is to add a few print statements to the source: the fast edit-test-debug cycle makes this simple approach very effective.</p> <p>Python is a popular programming language. It was created by Guido van Rossum, and released in 1991.</p> <p>source: Python </p>"},{"location":"python/namespaces-and-scope/","title":"Namespaces and Scope in Python","text":""},{"location":"python/classes/classes-and-objects/","title":"Classes and Objects","text":"<p>When you\u2019re just creating small scripts, chances are you don\u2019t need to create your own Python classes. But once you start creating larger applications, objects and classes allow you to organize your code naturally.</p> <p>A class in Python serves as a blueprint for creating objects, which are instances of the class. You use classes when you need to encapsulate related data and functions, making your code modular and easier to manage. By defining classes, you can create multiple objects that share the same attributes and methods, while maintaining their own unique state.</p> <p>You use classes to model complex data structures and behaviors in a modular way. Methods define behaviors, while attributes store data within class instances.</p>"},{"location":"python/classes/classes-and-objects/#getting-started-with-python-classes","title":"Getting Started With Python Classes","text":"<p>What is a class in Python? A common analogy is that a class is like the blueprint for a house. You can use the blueprint to create several houses and even a complete neighborhood. Each concrete house is an object or instance that\u2019s derived from the blueprint.</p> <p>Each instance can have its own properties, such as color, owner, and interior design. These properties carry what\u2019s commonly known as the object\u2019s state. Instances can also have different behaviors, such as locking the doors and windows, opening the garage door, turning the lights on and off, watering the garden, and more.</p> <p>In OOP, you commonly use the term attributes to refer to the properties or data associated with a specific object of a given class. In Python, attributes are variables defined inside a class with the purpose of storing all the required data for the class to work.</p> <p>Similarly, you\u2019ll use the term methods to refer to the different behaviors that objects will show. Methods are functions that you define within a class. These functions typically operate on or with the attributes of the underlying instance or class. Attributes and methods are collectively referred to as members of a class or object.</p> <p>You can write classes to model the real world. These classes will help you better organize your code and solve complex programming problems.</p> <p>For example, you can use classes to create objects that emulate people, animals, vehicles, books, buildings, cars, or other objects. You can also model virtual objects, such as a web server, directory tree, chatbot, file manager, and more.</p> <p>Finally, you can use classes to build class hierarchies. This way, you\u2019ll promote code reuse and remove repetition throughout your codebase.</p>"},{"location":"python/classes/classes-and-objects/#defining-a-class","title":"Defining a Class","text":"<p>To define a class, you need to use the class keyword followed by the class name and a colon, just like you\u2019d do for other compound statements in Python. Then you must define the class body, which will start at the next indentation level:</p> Syntax<pre><code>class ClassName:\n    &lt; body &gt;\n</code></pre> <p>In a class\u2019s body, you can define attributes and methods as needed. In Python, the body of a given class works as a namespace where attributes and methods live. You can only access those attributes and methods through the class or its objects.</p> circle.py<pre><code>import math\n\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    def calculate_area(self):\n        return math.pi * self.radius ** 2\n</code></pre> <p>code description:</p> <ul> <li>In this code snippet, you define <code>Circle</code> using the <code>class</code> keyword. Inside the class, you write two methods. The <code>.__   init__()</code> method has a special meaning in Python classes. This method is known as the object initializer because it   defines   and sets the initial values for the object\u2019s attributes.</li> <li>The second method of <code>Circle</code> is conveniently named <code>.calculate_area()</code> and will compute the area of a specific circle   by using its radius. In this example, you\u2019ve used the <code>math</code> module to access the pi constant as it\u2019s defined in that   module. It\u2019s common for method names to contain a verb, such as calculate, to describe an action the method performs.</li> <li>In Python, the first argument of most methods is <code>self</code>. This argument holds a reference to the current object so that   you can use it inside the class.</li> </ul>"},{"location":"python/classes/classes-and-objects/#creating-objects-from-a-class","title":"Creating Objects From a Class","text":""},{"location":"python/classes/classes-and-objects/#python-objects","title":"Python objects","text":"<p>You probably know the built-in <code>len()</code> function. It simply returns the length of the object you give it. But what is the length of, say, the number five? Let\u2019s ask Python:</p> <pre><code>&gt;&gt;&gt; len(5)\n</code></pre> output:<pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: object of type 'int' has no len()\n</code></pre> <p>In this case, Python is telling us that <code>5</code> is an object, and it has no <code>len()</code>. In Python, everything is an object. Strings, booleans, numbers, and even Python functions are objects.</p> <p>We can inspect an object in the REPL using the built-in function <code>dir()</code>. When we try <code>dir()</code> on the number <code>5</code>, it reveals a big list of functions that are part of any object of type <code>number</code>:</p> <pre><code>&gt;&gt;&gt; dir(5)\n</code></pre> output:<pre><code>['__abs__', '__add__', \n'__and__', '__bool__', \n'__ceil__', '__class__', \n...\n'__str__', '__sub__',\n '__subclasshook__', '__truediv__',\n '__trunc__', '__xor__', \n'bit_length', 'conjugate', \n'denominator', 'from_bytes',\n 'imag', 'numerator', \n'real', 'to_bytes']\n</code></pre> <p>The list starts with these weirdly named functions containing underscores, like <code>__add__</code> . These are called magic methods, or dunder methods (short for double underscore).</p> <p>If you look closely, you\u2019ll see that there\u2019s no <code>__len__</code> dunder method for objects of type <code>int</code>. That\u2019s how Python\u2019s <code>len()</code> function knows that a number does not have a length. All <code>len()</code> does, is call the <code>__len__()</code> method on the object you offered it. That\u2019s also why Python complained that \u201cobjects of type \u2018int\u2019 have no len().\u201d</p>"},{"location":"python/classes/classes-and-objects/#what-are-python-methods","title":"What are Python Methods?","text":""},{"location":"python/classes/classes-and-objects/#method","title":"Method","text":"<p>When a function is part of an object or Python class, we call it a method.</p> <p>A string must have a <code>len()</code> method:</p> <pre><code>dir(\"test\")\n</code></pre> output:<pre><code>['__add__', '__class__',\n...\n'__dir__', '__doc__', '__len__', \n... ]\n</code></pre> <p>And since this is a method, we can call it too:</p> <pre><code>\"test\".__len__()\n</code></pre> output:<pre><code>4\n</code></pre> <p>This is equivalent to <code>len(\"test\")</code> but a lot less elegant, so don\u2019t do this. It\u2019s just to illustrate how this stuff works. There\u2019s also a list of other, less magical methods that <code>dir()</code> revealed to us. like <code>islower()</code> and <code>replace()</code>:</p> <pre><code>\"test\".islower()\n</code></pre>"},{"location":"python/classes/classes-and-objects/#what-is-a-python-object","title":"What is a Python object?","text":"<p>Now that we\u2019ve used objects and know that everything in Python is an object, it\u2019s time to define what an object is:</p>"},{"location":"python/classes/classes-and-objects/#object","title":"Object","text":"<p>An object is a collection of data (variables) and methods that operate on that data. Objects are defined by a Python class.</p> <p>Objects and object-oriented programming are concepts that became popular in the early 1990s. It turned out that objects are an easy-to-understand paradigm for humans. Objects can be used to model many real-life concepts and situations.</p>"},{"location":"python/classes/classes-and-objects/#what-is-a-python-class","title":"What is a Python class?","text":"<p>Since objects are the building blocks of the Python language, it\u2019s only logical that you can create objects yourself too. If you want to create your own type of object, you first need to define its methods and what data it can hold. This blueprint is called a class.</p>"},{"location":"python/classes/classes-and-objects/#class","title":"Class","text":"<p>A class is the blueprint for one or more objects</p> <p>All Python objects are based on a class. When we create an object, we call this \u2018creating an instance of a class\u2019. Strings, numbers, and even booleans are instances of a class too. Let\u2019s explore with the built-in function <code>type()</code>:</p> <pre><code>&gt;&gt;&gt; type('a')\n&lt;class 'str'&gt;\n\n&gt;&gt;&gt; type(1)\n&lt;class 'int'&gt;\n\n&gt;&gt;&gt; type(True)\n&lt;class 'bool'&gt;\n</code></pre> <p>Apparently, there are classes called <code>str</code>, <code>int</code>, and <code>bool</code>. These are some of Python\u2019s native classes.</p>"},{"location":"python/classes/classes-and-objects/#class-definition","title":"Class Definition","text":"<p>Let\u2019s make a Python class that represents a car.</p> <pre><code>class Car:\n    speed = 0\n    started = False\n\n    def start(self):\n        self.started = True\n        print(\"Car started, let's ride!\")\n\n    def increase_speed(self, delta):\n        if self.started:\n            self.speed = self.speed + delta\n            print('Vrooooom!')\n        else:\n            print(\"You need to start the car first\")\n\n    def stop(self):\n        self.speed = 0\n        print('Halting')\n</code></pre>"},{"location":"python/classes/classes-and-objects/#create-a-python-object","title":"Create a Python object","text":"<p>create and use a Python object of type Car:</p> <pre><code>&gt;&gt;&gt; car = Car()\n&gt;&gt;&gt; car.increase_speed(10)\nYou need to start the car first\n\n&gt;&gt;&gt; car.start()\nCar started, let's ride!\n\n&gt;&gt;&gt; car.increase_speed(40)\nVrooooom!\n</code></pre> <p>An object in Python is always an instance of a class. One class can have many instances. We just created an instance of class <code>Car</code>, with <code>Car()</code>, and assigned it to the variable <code>car</code> . Creating an instance looks like calling a function.</p>"},{"location":"python/classes/classes-and-objects/#what-is-self-in-python","title":"What Is <code>self</code> in Python?","text":"<ul> <li>When we call a method on a Python object, Python automatically fills in the first variable, which we call self by   convention.</li> <li>This first variable is a reference to the object itself, hence its name.</li> <li>We can use this variable to reference other instance variables and functions of this object, like <code>self.speed</code> and   <code>self.start()</code></li> </ul> <p>So only inside the Python class definition, we use <code>self</code> to reference variables that are part of the instance. To modify the <code>started</code> variable that\u2019s part of our class, we use <code>self.started</code> and not just <code>started</code>. By using <code>self</code>, it\u2019s made abundantly clear that we are operating on a variable that\u2019s part of this instance and not some other variable that is defined outside the object and happens to have the same name.</p>"},{"location":"python/classes/classes-and-objects/#creating-multiple-python-objects","title":"Creating Multiple Python Objects","text":"<p>A Python class is just a blueprint, you can use it to create multiple objects, just like you can build multiple identical-looking cars. They all behave similarly, but they all have their own data that is not shared between objects:</p> <pre><code>&gt;&gt;&gt; car1 = Car()\n&gt;&gt;&gt; car2 = Car()\n&gt;&gt;&gt; id(car1)\n139771129539104\n\n&gt;&gt;&gt; id(car2)\n139771129539160\n</code></pre> <p>Each object in Python has a unique identifier, and used the built-in method <code>id()</code> to get their ids.</p> <p>source: Python Land source: Real Python</p>"},{"location":"python/classes/object-oriented-programming/","title":"Object-Oriented Programming (OOP)","text":"<p>Python classes form the backbone of object-oriented programming, enabling you to encapsulate data and behavior into a single entity. When you work with a Python class, you define attributes to store data and methods to perform actions. This structure allows you to model real-world objects and create organized, reusable code.</p> <p>Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build robust systems in Python that are more reusable and scalable.</p> <p>The four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.</p>"},{"location":"python/classes/object-oriented-programming/#what-is-object-oriented-programming-in-python","title":"What Is Object-Oriented Programming in Python?","text":"<p>Object-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects.</p> <p>OOP models real-world entities as software objects that have some data associated with them and can perform certain operations.</p> <p>The four key concepts of OOP in Python:</p> <ol> <li>Encapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive    unit.    By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity    and promotes modular, secure code.</li> <li>Inheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit    attributes and methods from a parent class. This promotes code reuse and reduces duplication.</li> <li>Abstraction focuses on hiding implementation details and exposing only the essential functionality of an object.    By    enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on    what an object does rather than how it achieves its functionality.</li> <li>Polymorphism allows you to treat objects of different types as instances of the same base type, as long as they    implement a common interface or behavior. Python\u2019s duck typing make it    especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to    worry about their actual class.</li> </ol>"},{"location":"python/classes/object-oriented-programming/#why-you-define-a-class-in-python","title":"Why You Define a Class in Python?","text":"<p>But what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative.</p> <p>For example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working.</p> <p>One way to do this is to represent each employee as a <code>list</code>:</p> <pre><code>kirk = [\"James Kirk\", 34, \"Captain\", 2265]\nspock = [\"Spock\", 35, \"Science Officer\", 2254]\nmccoy = [\"Leonard McCoy\", \"Chief Medical Officer\", 2266]\n</code></pre> <p>There are a number of issues with this approach. First, it can make larger code files more difficult to manage. If you reference <code>kirk[0]</code> several lines away from where you declared the <code>kirk</code> list, will you remember that the element with index <code>0</code> is the employee\u2019s name? Second, it can introduce errors if employees don\u2019t have the same number of elements in their respective lists. In the <code>mccoy</code> list above, the age is missing, so <code>mccoy[1]</code> will return <code>\"Chief Medical Officer\"</code> instead of Dr. McCoy\u2019s age.</p> <p>A great way to make this type of code more manageable and more maintainable is to use classes.</p> <pre><code>class Employee:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n</code></pre>"},{"location":"python/classes/object-oriented-programming/#classes-vs-instances","title":"Classes vs Instances","text":"<p>Classes allow you to create user-defined data structures. Classes define functions called <code>methods</code>, which identify the behaviors and actions that an object created from the class can perform with its data.</p> <p>In this tutorial, you\u2019ll create a Dog class that stores some information about the characteristics and behaviors that an individual dog can have.</p> <p>A class is a blueprint for how to define something. It doesn\u2019t actually contain any data. The Dog class specifies that a name and an age are necessary for defining a dog, but it doesn\u2019t contain the name or age of any specific dog.</p> <p>While the class is the blueprint, an instance is an object that\u2019s built from a class and contains real data. An instance of the Dog class is not a blueprint anymore. It\u2019s an actual dog with a name, like Miles, who\u2019s four years old.</p> <p>Put another way, a class is like a form or questionnaire. An instance is like a form that you\u2019ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class.</p> <p>source: Real Python</p>"},{"location":"python/syntax/python-syntax/","title":"Python Syntax","text":"<p>Python was designed for readability, and has some similarities to the English language with influence from mathematics. Python uses new lines to complete a command, as opposed to other programming languages which often use semicolons or parentheses. Python relies on indentation, using whitespace, to define scope; such as the scope of loops, functions and classes. Other programming languages often use curly-brackets for this purpose.</p>"},{"location":"python/syntax/python-syntax/#execute-python-syntax","title":"Execute Python Syntax","text":"<p>As we learned in the previous page, Python syntax can be executed by writing directly in the Command Line:</p> <pre><code>&gt;&gt;&gt; print(\"Hello, World!\")\nHello, World! \n</code></pre> <p>Or by creating a python file on the server, using the .py file extension, and running it in the Command Line:</p> <pre><code>C:\\Users\\YourName&gt;python myfile.py \n</code></pre>"},{"location":"python/syntax/python-syntax/#python-indentation","title":"Python Indentation","text":"<p>Indentation refers to the spaces at the beginning of a code line. Where in other programming languages the indentation in code is for readability only, the indentation in Python is very important. Python uses indentation to indicate a block of code. The number of spaces is up to you as a programmer, the most common use is four, but it has to be at least one.</p> <pre><code>if 5 &gt; 2:\n    print(\"Five is greater than two!\")\n</code></pre> <p>You have to use the same number of spaces in the same block of code, otherwise Python will give you an error.</p> Syntax Error<pre><code>if 5 &gt; 2:\n  print(\"Five is greater than two!\")\n        print(\"Five is greater than two!\") \n</code></pre>"},{"location":"python/syntax/python-syntax/#comments","title":"Comments","text":"<p>Comments can be used to explain Python code. Comments can be used to make the code more readable. Comments can be used to prevent execution when testing code.</p> <p>Comments starts with a <code>#</code>, and Python will ignore them:</p> <pre><code># This is a comment\nprint(\"Hello, World!\")\n</code></pre> <p>Comments can be placed at the end of a line, and Python will ignore the rest of the line:</p> <pre><code>print(\"Hello, World!\")  # This is a comment \n</code></pre> <p>A comment does not have to be text that explains the code, it can also be used to prevent Python from executing code:</p> <pre><code># print(\"Hello, World!\")\nprint(\"Cheers, Mate!\") \n</code></pre>"},{"location":"python/syntax/python-syntax/#multiline-comments","title":"Multiline Comments","text":"<p>Python does not really have a syntax for multiline comments. To add a multiline comment you could insert a <code>#</code> for each line:</p> <pre><code># This is a comment\n# written in\n# more than just one line\nprint(\"Hello, World!\")\n</code></pre> <p>Or, not quite as intended, you can use a multiline string. Since Python will ignore string literals that are not assigned to a variable, you can add a multiline string (triple quotes) in your code, and place your comment inside it.</p> <pre><code>\"\"\"\nThis is a comment\nwritten in\nmore than just one line\n\"\"\"\nprint(\"Hello, World!\") \n</code></pre> <p>As long as the string is not assigned to a variable, Python will read the code, but then ignore it, and you have made a multiline comment.</p> <p>source: w3schools </p>"}]}